/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => AnkifyPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  apiModel: "deepseek",
  deepseekApiKey: "",
  openaiApiKey: "",
  claudeApiKey: "",
  geminiApiKey: "", // [Gemini] 1. 添加 Gemini API 密钥的默认设置
  customApiUrl: "https://api.example.com/v1/chat/completions",
  customApiKey: "",
  customModelName: "custom-model",
  customApiVersion: "",
  customPrompt: '\u8BF7\u57FA\u4E8E\u4EE5\u4E0B\u5185\u5BB9\u521B\u5EFAAnki\u5361\u7247\uFF0C\u683C\u5F0F\u4E3A"\u95EE\u9898:::\u7B54\u6848"\uFF0C\u6BCF\u4E2A\u5361\u7247\u4E00\u884C\u3002\u63D0\u53D6\u5173\u952E\u6982\u5FF5\u548C\u77E5\u8BC6\u70B9\u3002\n\n',
  insertToDocument: false,
  ankiConnectUrl: "http://127.0.0.1:8765",
  defaultDeck: "Default",
  defaultNoteType: "Basic"
};
var AnkifyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "generate-anki-cards",
      name: "\u751F\u6210Anki\u5361\u7247",
      editorCallback: (editor, view) => {
        this.processContent(editor, view);
      }
    });
    this.addSettingTab(new AnkifySettingTab(this.app, this));
    this.addRibbonIcon("dice", "Ankify\u9009\u4E2D\u5185\u5BB9", (evt) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view) {
        this.processContent(view.editor, view);
      } else {
        new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2AMarkdown\u6587\u4EF6");
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async invokeAnkiConnect(action, params = {}) {
    const requestBody = {
      action,
      version: 6,
      params
    };
    console.log("\u53D1\u9001Anki Connect\u8BF7\u6C42:", {
      url: this.settings.ankiConnectUrl,
      action,
      params
    });
    const response = await fetch(this.settings.ankiConnectUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      throw new Error(`Anki Connect\u8BF7\u6C42\u5931\u8D25: ${response.statusText}`);
    }
    const data = await response.json();
    console.log("Anki Connect\u54CD\u5E94:", data);
    if (data.error) {
      throw new Error(`Anki Connect\u9519\u8BEF: ${data.error}`);
    }
    return data.result;
  }
  async getDeckNames() {
    try {
      return await this.invokeAnkiConnect("deckNames");
    } catch (error) {
      console.error("\u83B7\u53D6\u724C\u7EC4\u5217\u8868\u5931\u8D25:", error);
      new import_obsidian.Notice("\u83B7\u53D6Anki\u724C\u7EC4\u5217\u8868\u5931\u8D25\uFF0C\u8BF7\u786E\u4FDDAnki\u5DF2\u542F\u52A8\u4E14\u5B89\u88C5\u4E86Anki Connect\u63D2\u4EF6");
      return [];
    }
  }
  async getNoteTypes() {
    try {
      return await this.invokeAnkiConnect("modelNames");
    } catch (error) {
      console.error("\u83B7\u53D6\u7B14\u8BB0\u7C7B\u578B\u5217\u8868\u5931\u8D25:", error);
      return [];
    }
  }
  parseAnkiCards(text) {
    var _a, _b, _c;
    const cards = [];
    const isMultiLineFormat = /Q:.*\nA:.*(\nannotation:.*)?(\ntags:.*)?/i.test(text);
    if (isMultiLineFormat) {
      console.log("\u68C0\u6D4B\u5230\u591A\u884C\u683C\u5F0F\u6570\u636E");
      const cardBlocks = text.split(/\n\s*\n+/).filter((block) => block.trim());
      for (const block of cardBlocks) {
        const lines = block.split("\n").map((line) => line.trim()).filter((line) => line);
        const card = { question: "", answer: "" };
        for (const line of lines) {
          if (line.startsWith("Q:")) {
            card.question = line.substring(2).trim();
          } else if (line.startsWith("A:")) {
            card.answer = line.substring(2).trim();
          } else if (line.startsWith("annotation:")) {
            card.annotation = line.substring(11).trim();
          } else if (line.startsWith("tags:")) {
            const tagsText = line.substring(5).trim();
            if (tagsText.includes("#")) {
              card.tags = tagsText.split("#").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
            } else {
              card.tags = tagsText.split(/[\s,]+/).map((tag) => tag.trim()).filter((tag) => tag.length > 0);
            }
          }
        }
        if (card.question && card.answer) {
          cards.push(card);
        }
      }
    } else {
      const lines = text.split("\n").filter((line) => line.trim());
      if (lines.length === 0) {
        return cards;
      }
      const headerLine = lines[0].trim();
      const isTableFormat = /^Q[\t\s]+A[\t\s]+annotation[\t\s]+tags$/i.test(headerLine);
      if (isTableFormat) {
        console.log("\u68C0\u6D4B\u5230\u8868\u683C\u683C\u5F0F\u6570\u636E");
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line)
            continue;
          let parts;
          if (line.includes(" ")) {
            parts = line.split("  ");
          } else {
            parts = line.split(/\s{2,}/);
          }
          if (parts.length >= 2) {
            const card = {
              question: parts[0].trim(),
              answer: parts[1].trim()
            };
            if (parts.length >= 3 && parts[2].trim()) {
              card.annotation = parts[2].trim();
            }
            if (parts.length >= 4 && parts[3].trim()) {
              const tagsText = parts[3].trim();
              if (tagsText) {
                if (tagsText.includes("#")) {
                  const tagParts = tagsText.split("#");
                  card.tags = tagParts.map((tag) => tag.trim()).filter((tag) => tag.length > 0);
                } else {
                  card.tags = tagsText.split(/[\s,]+/).map((tag) => tag.trim()).filter((tag) => tag.length > 0);
                }
              }
            }
            cards.push(card);
          }
        }
      } else {
        for (const line of lines) {
          const qaMatch = line.match(/Q:\s*(.*?)\s*A:\s*(.*?)(?:\s*annotation:|$|\s*tags:)/i);
          if (qaMatch) {
            const card = {
              question: ((_a = qaMatch[1]) == null ? void 0 : _a.trim()) || "",
              answer: ((_b = qaMatch[2]) == null ? void 0 : _b.trim()) || ""
            };
            const annotationMatch = line.match(/annotation:\s*(.*?)(?:\s*tags:|$)/i);
            if (annotationMatch) {
              card.annotation = (_c = annotationMatch[1]) == null ? void 0 : _c.trim();
            }
            const tagsMatch = line.match(/tags:\s*(.*?)$/i);
            if (tagsMatch && tagsMatch[1]) {
              card.tags = tagsMatch[1].split("#").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
            }
            cards.push(card);
          } else {
            const splitLine = line.split(":::");
            if (splitLine.length >= 2) {
              cards.push({
                question: splitLine[0].trim(),
                answer: splitLine[1].trim()
              });
            }
          }
        }
      }
    }
    console.log(`\u89E3\u6790\u51FA ${cards.length} \u5F20\u5361\u7247`);
    return cards;
  }
  async addNotesToAnki(cards, deckName, noteType) {
    if (!deckName || !noteType) {
      throw new Error("\u724C\u7EC4\u540D\u79F0\u548C\u7B14\u8BB0\u7C7B\u578B\u4E0D\u80FD\u4E3A\u7A7A");
    }
    console.log("\u51C6\u5907\u6DFB\u52A0\u5361\u7247\u5230Anki:", {
      deckName,
      noteType,
      cardCount: cards.length,
      firstCard: cards[0]
    });
    const notes = await Promise.all(cards.map(async (card, index) => {
      if (!card.question || !card.answer) {
        throw new Error(`\u5361\u7247\u5185\u5BB9\u4E0D\u5B8C\u6574\uFF1A
\u95EE\u9898\uFF1A${card.question}
\u7B54\u6848\uFF1A${card.answer}`);
      }
      let fields = {};
      const modelFieldNames = await this.invokeAnkiConnect("modelFieldNames", { modelName: noteType });
      console.log(`\u7B14\u8BB0\u7C7B\u578B ${noteType} \u7684\u5B57\u6BB5\u540D\u79F0:`, modelFieldNames);
      if (modelFieldNames.includes("Front") && modelFieldNames.includes("Back")) {
        fields = {
          Front: card.question,
          Back: card.answer + (card.annotation ? `
<hr>
<span style="color: rgb(143, 53, 8);">${card.annotation}</span>` : "")
        };
      } else if (modelFieldNames.includes("\u6B63\u9762") && modelFieldNames.includes("\u80CC\u9762")) {
        fields = {
          \u6B63\u9762: card.question,
          \u80CC\u9762: card.answer + (card.annotation ? `
<hr>
<span style="color: rgb(143, 53, 8);">${card.annotation}</span>` : "")
        };
      } else if (modelFieldNames.includes("Text") && modelFieldNames.includes("Extra")) {
        fields = {
          Text: card.question,
          Extra: card.answer + (card.annotation ? `
<hr>
<span style="color: rgb(143, 53, 8);">${card.annotation}</span>` : "")
        };
      } else {
        if (modelFieldNames.length >= 2) {
          fields = {
            [modelFieldNames[0]]: card.question,
            [modelFieldNames[1]]: card.answer + (card.annotation ? `
<hr>
<span style="color: rgb(143, 53, 8);">${card.annotation}</span>` : "")
          };
        } else {
          throw new Error(`\u65E0\u6CD5\u786E\u5B9A\u7B14\u8BB0\u7C7B\u578B ${noteType} \u7684\u5B57\u6BB5\u6620\u5C04`);
        }
      }
      for (const [key, value] of Object.entries(fields)) {
        if (!value || value.trim() === "") {
          throw new Error(`\u5B57\u6BB5 "${key}" \u4E0D\u80FD\u4E3A\u7A7A`);
        }
      }
      const note = {
        deckName,
        modelName: noteType,
        fields,
        tags: card.tags || [],
        options: {
          allowDuplicate: false
        }
      };
      console.log(`\u7B2C ${index + 1} \u5F20\u5361\u7247\u7684\u5B8C\u6574\u7B14\u8BB0\u5BF9\u8C61:`, note);
      return note;
    }));
    try {
      console.log("\u6B63\u5728\u6DFB\u52A0\u7B14\u8BB0\u5230Anki:", {
        deckName,
        noteType,
        noteCount: notes.length,
        firstNote: notes[0]
      });
      const result = await this.invokeAnkiConnect("addNotes", { notes });
      if (!result || !Array.isArray(result)) {
        throw new Error("Anki Connect\u8FD4\u56DE\u4E86\u65E0\u6548\u7684\u7ED3\u679C");
      }
      const failedNotes = result.filter((id) => id === null);
      if (failedNotes.length > 0) {
        console.warn(`\u6709 ${failedNotes.length} \u5F20\u5361\u7247\u6DFB\u52A0\u5931\u8D25`);
      }
      return result;
    } catch (error) {
      console.error("\u6DFB\u52A0\u7B14\u8BB0\u5931\u8D25:", error);
      throw new Error(`\u6DFB\u52A0\u7B14\u8BB0\u5931\u8D25: ${error.message}`);
    }
  }
  async processContent(editor, view) {
    const selectedText = editor.getSelection();
    if (!selectedText) {
      new import_obsidian.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u5904\u7406\u7684\u6587\u672C\u5185\u5BB9");
      return;
    }
    let apiKey = "";
    const model = this.settings.apiModel;
    if (model === "deepseek") {
      apiKey = this.settings.deepseekApiKey;
    } else if (model === "openai") {
      apiKey = this.settings.openaiApiKey;
    } else if (model === "claude") {
      apiKey = this.settings.claudeApiKey;
    } else if (model === "gemini") { // [Gemini] 2. 添加 Gemini API 密钥检查
      apiKey = this.settings.geminiApiKey;
    } else if (model === "custom") {
      apiKey = this.settings.customApiKey;
      if (!this.settings.customApiUrl) {
        new import_obsidian.Notice("\u8BF7\u5148\u8BBE\u7F6E\u81EA\u5B9A\u4E49API URL");
        return;
      }
      if (!this.settings.customModelName) {
        new import_obsidian.Notice("\u8BF7\u5148\u8BBE\u7F6E\u81EA\u5B9A\u4E49\u6A21\u578B\u540D\u79F0");
        return;
      }
    }
    if (!apiKey) {
      // [Gemini] 2.1 添加 "Gemini" 到提示消息
      const modelName = model === "deepseek" ? "DeepSeek" : model === "openai" ? "OpenAI" : model === "claude" ? "Claude" : model === "gemini" ? "Gemini" : "\u81EA\u5B9A\u4E49API";
      new import_obsidian.Notice(`\u8BF7\u5148\u8BBE\u7F6E${modelName}\u5BC6\u94A5`);
      return;
    }
    new import_obsidian.Notice("\u6B63\u5728\u751F\u6210Anki\u5361\u7247...");
    try {
      const result = await this.callModelAPI(selectedText);
      if (this.settings.insertToDocument) {
        this.appendResultToDocument(editor, result);
      } else {
        const cards = this.parseAnkiCards(result);
        new SelectableCardsModal(this.app, cards, result, this, editor).open();
      }
    } catch (error) {
      console.error("API\u8C03\u7528\u5931\u8D25:", error);
      new import_obsidian.Notice("\u751F\u6210Anki\u5361\u7247\u5931\u8D25\uFF1A" + error.message);
    }
  }
  appendResultToDocument(editor, result) {
    const docContent = editor.getValue();
    const newContent = docContent + "\n\n## Anki\u5361\u7247\n\n" + result;
    editor.setValue(newContent);
    new import_obsidian.Notice("Anki\u5361\u7247\u5DF2\u6DFB\u52A0\u5230\u6587\u6863\u672B\u5C3E");
  }
  async callModelAPI(content) {
    var _a, _b, _c, _d, _e, _f, _g;
    const prompt = this.settings.customPrompt + content;
    const startTime = Date.now();
    const model = this.settings.apiModel;
    let apiUrl = "";
    let headers = {
      "Content-Type": "application/json"
    };
    let requestBody = {};
    if (model === "deepseek") {
      apiUrl = "https://api.deepseek.com/v1/chat/completions";
      headers["Authorization"] = `Bearer ${this.settings.deepseekApiKey}`;
      requestBody = {
        model: "deepseek-chat",
        messages: [
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.7
      };
    } else if (model === "openai") {
      apiUrl = "https://api.openai.com/v1/chat/completions";
      headers["Authorization"] = `Bearer ${this.settings.openaiApiKey}`;
      requestBody = {
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.7
      };
    } else if (model === "claude") {
      apiUrl = "https://api.anthropic.com/v1/messages";
      headers["x-api-key"] = this.settings.claudeApiKey;
      headers["anthropic-version"] = "2023-06-01";
      requestBody = {
        model: "claude-3-haiku-20240307",
        messages: [
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 1e3,
        temperature: 0.7
      };
    } else if (model === "gemini") { // [Gemini] 3. 添加 Gemini API 的请求逻辑
      // 你可以把这里的 "gemini-1.5-flash-latest" 换成你的 "gemini-2.5-flash"
      const geminiModel = "gemini-2.5-flash";
      apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${this.settings.geminiApiKey}`;
      
      // Gemini 的 API Key 是在 URL 参数中，Headers 里不需要 Authorization
      headers = {
        "Content-Type": "application/json"
      };
      
      // Gemini 的请求体结构 (contents) 和 OpenAI/Claude (messages) 不同
      requestBody = {
        "contents": [
          {
            "role": "user",
            "parts": [
              { "text": prompt }
            ]
          }
        ],
        "generationConfig": {
          "temperature": 0.7
        }
      };
    } else if (model === "custom") {
      apiUrl = this.settings.customApiUrl;
      headers["Authorization"] = `Bearer ${this.settings.customApiKey}`;
      if (this.settings.customApiVersion) {
        headers["api-version"] = this.settings.customApiVersion;
      }
      if (apiUrl.includes("openai")) {
        requestBody = {
          model: this.settings.customModelName,
          messages: [
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0.7
        };
      } else if (apiUrl.includes("anthropic")) {
        requestBody = {
          model: this.settings.customModelName,
          messages: [
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: 1e3,
          temperature: 0.7
        };
      } else {
        requestBody = {
          model: this.settings.customModelName,
          messages: [
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0.7
        };
      }
    } else {
      throw new Error("\u4E0D\u652F\u6301\u7684\u6A21\u578B\u7C7B\u578B");
    }
    const response = await fetch(apiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      const errorData = await response.json();
      console.error("API Error Response:", errorData); // 打印详细错误
      throw new Error(((_a = errorData.error) == null ? void 0 : _a.message) || `\u8BF7\u6C42\u5931\u8D25: ${errorData.message || response.statusText}`);
    }
    const data = await response.json();
    const endTime = Date.now();
    console.log(`${model.toUpperCase()} API\u54CD\u5E94\u65F6\u95F4: ${endTime - startTime}ms`);
    let result = "";
    if (model === "deepseek" || model === "openai") {
      result = ((_c = (_b = data.choices[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "\u65E0\u6CD5\u751F\u6210\u5361\u7247\u5185\u5BB9";
    } else if (model === "claude") {
      result = ((_d = data.content[0]) == null ? void 0 : _d.text) || "\u65E0\u6CD5\u751F\u6210\u5361\u7247\u5185\u5BB9";
    } else if (model === "gemini") { // [Gemini] 3.1 添加 Gemini 响应的解析逻辑
      try {
        // Gemini 的响应结构是 data.candidates[0].content.parts[0].text
        result = data.candidates[0].content.parts[0].text;
      } catch (e) {
        console.error("Error parsing Gemini response:", e, data);
        if (data.promptFeedback && data.promptFeedback.blockReason) {
          result = `\u5185\u5BB9\u88ABGemini\u5B89\u5168\u7B56\u7565\u62E6\u622A: ${data.promptFeedback.blockReason}`;
        } else {
          result = "\u65E0\u6CD5\u89E3\u6790Gemini\u54CD\u5E94";
        }
      }
    } else if (model === "custom") {
      if (data.choices && ((_f = (_e = data.choices[0]) == null ? void 0 : _e.message) == null ? void 0 : _f.content)) {
        result = data.choices[0].message.content;
      } else if (data.content && ((_g = data.content[0]) == null ? void 0 : _g.text)) {
        result = data.content[0].text;
      } else if (data.response) {
        result = data.response;
      } else if (data.text || data.content || data.result || data.output || data.generated_text) {
        result = data.text || data.content || data.result || data.output || data.generated_text;
      } else {
        console.warn("\u65E0\u6CD5\u4ECEAPI\u54CD\u5E94\u4E2D\u63D0\u53D6\u5185\u5BB9\uFF0C\u8FD4\u56DE\u5B8C\u6574\u54CD\u5E94:", data);
        result = JSON.stringify(data, null, 2);
      }
    }
    return result;
  }
};
var SelectableCardsModal = class extends import_obsidian.Modal {
  constructor(app, cards, rawResult, plugin, editor) {
    super(app);
    this.cards = cards;
    this.rawResult = rawResult;
    this.plugin = plugin;
    this.editor = editor;
    this.selectedCards = cards.map(() => true);
    this.deckName = plugin.settings.defaultDeck;
    this.noteType = plugin.settings.defaultNoteType;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.position = "fixed";
    this.modalEl.style.top = "50%";
    this.modalEl.style.left = "50%";
    this.modalEl.style.transform = "translate(-50%, -50%)";
    this.modalEl.style.width = "80%";
    this.modalEl.style.maxWidth = "800px";
    this.modalEl.style.maxHeight = "80vh";
    this.modalEl.style.overflow = "auto";
    this.loadingEl = contentEl.createDiv({ cls: "ankify-loading" });
    this.loadingEl.createEl("div", { cls: "ankify-loading-spinner" });
    this.loadingEl.createEl("div", { text: "\u6B63\u5728\u52A0\u8F7D..." });
    this.loadContent().then(() => {
      this.loadingEl.remove();
    });
  }
  async loadContent() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Anki\u5361\u7247\u9009\u62E9" });
    if (this.cards.length === 0) {
      contentEl.createEl("p", {
        text: "\u672A\u80FD\u89E3\u6790\u51FA\u6709\u6548\u7684Anki\u5361\u7247\uFF0C\u8BF7\u68C0\u67E5\u751F\u6210\u7ED3\u679C\u683C\u5F0F\u3002"
      });
      const rawResultEl = contentEl.createDiv({ cls: "ankify-raw-result" });
      const textAreaEl = rawResultEl.createEl("textarea", {
        cls: "ankify-editable-result",
        text: this.rawResult
      });
      textAreaEl.style.width = "100%";
      textAreaEl.style.height = "100px";
      const buttonContainer2 = contentEl.createDiv({
        cls: "ankify-button-container"
      });
      const copyButton2 = buttonContainer2.createEl("button", {
        text: "\u590D\u5236\u5185\u5BB9"
      });
      copyButton2.addEventListener("click", () => {
        navigator.clipboard.writeText(textAreaEl.value);
        new import_obsidian.Notice("\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F");
      });
      const insertButton2 = buttonContainer2.createEl("button", {
        text: "\u63D2\u5165\u5230\u6587\u6863"
      });
      insertButton2.addEventListener("click", () => {
        const docContent = this.editor.getValue();
        const newContent = docContent + "\n\n## Anki\u5361\u7247\n\n" + textAreaEl.value;
        this.editor.setValue(newContent);
        new import_obsidian.Notice("\u5185\u5BB9\u5DF2\u6DFB\u52A0\u5230\u6587\u6863\u672B\u5C3E");
        this.close();
      });
      return;
    }
    const ankiSettingsEl = contentEl.createDiv({ cls: "ankify-anki-settings" });
    let decks = [];
    try {
      decks = await this.plugin.getDeckNames();
    } catch (error) {
      ankiSettingsEl.createEl("p", {
        cls: "ankify-error",
        text: "\u65E0\u6CD5\u8FDE\u63A5\u5230Anki\u3002\u8BF7\u786E\u4FDDAnki\u5DF2\u7ECF\u542F\u52A8\uFF0C\u4E14\u5DF2\u5B89\u88C5Anki Connect\u63D2\u4EF6\u3002"
      });
    }
    const deckContainer = ankiSettingsEl.createDiv({
      cls: "ankify-setting-item"
    });
    deckContainer.createEl("label", { text: "\u9009\u62E9\u724C\u7EC4\uFF1A" });
    this.deckSelect = deckContainer.createEl("select");
    if (decks.length > 0) {
      decks.forEach((deck) => {
        const option = this.deckSelect.createEl("option", {
          value: deck,
          text: deck
        });
        if (deck === this.plugin.settings.defaultDeck) {
          option.selected = true;
          this.deckName = deck;
        }
      });
    } else {
      this.deckSelect.createEl("option", {
        value: this.deckName,
        text: this.deckName
      });
    }
    this.deckSelect.addEventListener("change", () => {
      this.deckName = this.deckSelect.value;
    });
    const noteTypes = await this.plugin.getNoteTypes();
    const noteTypeContainer = ankiSettingsEl.createDiv({
      cls: "ankify-setting-item"
    });
    noteTypeContainer.createEl("label", { text: "\u7B14\u8BB0\u7C7B\u578B\uFF1A" });
    this.noteTypeSelect = noteTypeContainer.createEl("select");
    if (noteTypes.length > 0) {
      noteTypes.forEach((type) => {
        const option = this.noteTypeSelect.createEl("option", {
          value: type,
          text: type
        });
        if (type === this.plugin.settings.defaultNoteType) {
          option.selected = true;
          this.noteType = type;
        }
      });
    } else {
      const basicTypes = [
        "Basic",
        "Basic (and reversed card)",
        "Cloze",
        "Basic (optional reversed card)"
      ];
      basicTypes.forEach((type) => {
        const option = this.noteTypeSelect.createEl("option", {
          value: type,
          text: type
        });
        if (type === this.plugin.settings.defaultNoteType) {
          option.selected = true;
          this.noteType = type;
        }
      });
    }
    this.noteTypeSelect.addEventListener("change", () => {
      this.noteType = this.noteTypeSelect.value;
    });
    const cardsContainer = contentEl.createDiv({
      cls: "ankify-cards-container"
    });
    const selectAllContainer = cardsContainer.createDiv({
      cls: "ankify-select-all"
    });
    const selectAllCheckbox = selectAllContainer.createEl("input", {
      type: "checkbox"
    });
    selectAllCheckbox.checked = true;
    selectAllContainer.createEl("label", { text: "\u5168\u9009/\u5168\u4E0D\u9009" });
    selectAllCheckbox.addEventListener("change", () => {
      this.selectedCards = this.selectedCards.map(() => selectAllCheckbox.checked);
      this.updateCardSelectionDisplay();
    });
    const cardsListEl = cardsContainer.createDiv({ cls: "ankify-cards-list" });
    this.cards.forEach((card, index) => {
      const cardEl = cardsListEl.createDiv({ cls: "ankify-card" });
      const checkboxContainer = cardEl.createDiv({
        cls: "ankify-card-checkbox"
      });
      const checkbox = checkboxContainer.createEl("input", {
        type: "checkbox",
        attr: { id: `card-checkbox-${index}` }
      });
      checkbox.checked = this.selectedCards[index];
      checkbox.addEventListener("change", () => {
        this.selectedCards[index] = checkbox.checked;
      });
      const cardContent = cardEl.createDiv({ cls: "ankify-card-content" });
      const questionEl = cardContent.createDiv({ cls: "ankify-card-question" });
      questionEl.createEl("strong", { text: "\u95EE\u9898: " });
      const questionInput = questionEl.createEl("input", {
        cls: "ankify-card-input",
        type: "text",
        value: card.question
      });
      questionInput.addEventListener("change", () => {
        this.cards[index].question = questionInput.value;
      });
      const answerEl = cardContent.createDiv({ cls: "ankify-card-answer" });
      answerEl.createEl("strong", { text: "\u7B54\u6848: " });
      const answerInput = answerEl.createEl("input", {
        cls: "ankify-card-input",
        type: "text",
        value: card.answer
      });
      answerInput.addEventListener("change", () => {
        this.cards[index].answer = answerInput.value;
      });
      if (card.annotation) {
        const annotationEl = cardContent.createDiv({
          cls: "ankify-card-annotation"
        });
        annotationEl.createEl("strong", { text: "\u6CE8\u91CA: " });
        const annotationInput = annotationEl.createEl("input", {
          cls: "ankify-card-input",
          type: "text",
          value: card.annotation
        });
        annotationInput.addEventListener("change", () => {
          this.cards[index].annotation = annotationInput.value;
        });
      }
      if (card.tags && card.tags.length > 0) {
        const tagsEl = cardContent.createDiv({ cls: "ankify-card-tags" });
        tagsEl.createEl("strong", { text: "\u6807\u7B7E: " });
        const tagsInput = tagsEl.createEl("input", {
          cls: "ankify-card-input",
          type: "text",
          value: card.tags.join(" ")
        });
        tagsInput.addEventListener("change", () => {
          this.cards[index].tags = tagsInput.value.split(/\s+/).map((tag) => tag.trim()).filter((tag) => tag.length > 0);
        });
      }
    });
    const buttonContainer = contentEl.createDiv({
      cls: "ankify-button-container"
    });
    const addToAnkiButton = buttonContainer.createEl("button", {
      cls: "ankify-primary-button",
      text: "\u6DFB\u52A0\u5230Anki"
    });
    addToAnkiButton.addEventListener("click", async () => {
      const selectedCardsList = this.cards.filter((_, index) => this.selectedCards[index]);
      if (selectedCardsList.length === 0) {
        new import_obsidian.Notice("\u8BF7\u81F3\u5C11\u9009\u62E9\u4E00\u5F20\u5361\u7247");
        return;
      }
      try {
        const loadingNotice = new import_obsidian.Notice("\u6B63\u5728\u6DFB\u52A0\u5361\u7247\u5230Anki...", 0);
        const result = await this.plugin.addNotesToAnki(selectedCardsList, this.deckName, this.noteType);
        this.plugin.settings.defaultDeck = this.deckName;
        this.plugin.settings.defaultNoteType = this.noteType;
        await this.plugin.saveSettings();
        const successCount = result.filter((id) => id !== null).length;
        loadingNotice.hide();
        new import_obsidian.Notice(`\u6210\u529F\u6DFB\u52A0 ${successCount}/${selectedCardsList.length} \u5F20\u5361\u7247\u5230Anki`);
        this.close();
      } catch (error) {
        new import_obsidian.Notice(`\u6DFB\u52A0\u5361\u7247\u5931\u8D25: ${error.message}`);
      }
    });
    const copyButton = buttonContainer.createEl("button", {
      text: "\u590D\u5236\u5168\u90E8\u5185\u5BB9"
    });
    copyButton.addEventListener("click", () => {
      navigator.clipboard.writeText(this.rawResult);
      new import_obsidian.Notice("\u5DF2\u590D\u5236\u539F\u59CB\u5185\u5BB9\u5230\u526A\u8D34\u677F");
    });
    const insertButton = buttonContainer.createEl("button", {
      text: "\u63D2\u5165\u5230\u6587\u6863"
    });
    insertButton.addEventListener("click", () => {
      const docContent = this.editor.getValue();
      const newContent = docContent + "\n\n## Anki\u5361\u7247\n\n" + this.rawResult;
      this.editor.setValue(newContent);
      new import_obsidian.Notice("\u5185\u5BB9\u5DF2\u6DFB\u52A0\u5230\u6587\u6863\u672B\u5C3E");
      this.close();
    });
  }
  updateCardSelectionDisplay() {
    this.selectedCards.forEach((isSelected, index) => {
      const checkbox = document.getElementById(`card-checkbox-${index}`);
      if (checkbox) {
        checkbox.checked = isSelected;
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AnkifySettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Ankify \u63D2\u4EF6\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("AI\u6A21\u578B\u9009\u62E9").setDesc("\u9009\u62E9\u7528\u4E8E\u751F\u6210Anki\u5361\u7247\u7684AI\u6A21\u578B").addDropdown((dropdown) => {
      dropdown.addOption("deepseek", "DeepSeek").addOption("openai", "OpenAI").addOption("claude", "Claude").addOption("gemini", "Gemini").addOption("custom", "\u81EA\u5B9A\u4E49API").setValue(this.plugin.settings.apiModel).onChange(async (value) => { // [Gemini] 4. 在下拉菜单中添加 "Gemini"
        this.plugin.settings.apiModel = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.apiModel === "deepseek") {
      new import_obsidian.Setting(containerEl).setName("DeepSeek API \u5BC6\u94A5").setDesc("\u8F93\u5165\u60A8\u7684DeepSeek API\u5BC6\u94A5").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.deepseekApiKey).onChange(async (value) => {
        this.plugin.settings.deepseekApiKey = value;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.apiModel === "openai") {
      new import_obsidian.Setting(containerEl).setName("OpenAI API \u5BC6\u94A5").setDesc("\u8F93\u5165\u60A8\u7684OpenAI API\u5BC6\u94A5").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.apiModel === "claude") {
      new import_obsidian.Setting(containerEl).setName("Claude API \u5BC6\u94A5").setDesc("\u8F93\u5165\u60A8\u7684Claude API\u5BC6\u94A5").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.claudeApiKey).onChange(async (value) => {
        this.plugin.settings.claudeApiKey = value;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.apiModel === "gemini") { // [Gemini] 4.1 添加 Gemini API 密钥输入框
      new import_obsidian.Setting(containerEl).setName("Gemini API \u5BC6\u94A5").setDesc("\u8F93\u5165\u60A8\u7684 Google AI Studio Gemini API \u5BC6\u94A5").addText((text) => text.setPlaceholder("...").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value;
        await this.plugin.saveSettings(); // [Gemini - FIX] 补上这一行来保存设置
      }));
    } else if (this.plugin.settings.apiModel === "custom") {
      containerEl.createEl("h3", { text: "\u81EA\u5B9A\u4E49API\u8BBE\u7F6E" });
      new import_obsidian.Setting(containerEl).setName("API URL").setDesc("\u8F93\u5165\u81EA\u5B9A\u4E49API\u7684\u5B8C\u6574URL").addText((text) => text.setPlaceholder("https://api.example.com/v1/chat/completions").setValue(this.plugin.settings.customApiUrl).onChange(async (value) => {
        this.plugin.settings.customApiUrl = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("API \u5BC6\u94A5").setDesc("\u8F93\u5165\u81EA\u5B9A\u4E49API\u7684\u5BC6\u94A5").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.customApiKey).onChange(async (value) => {
        this.plugin.settings.customApiKey = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("\u6A21\u578B\u540D\u79F0").setDesc("\u8F93\u5165\u8981\u4F7F\u7528\u7684\u6A21\u578B\u540D\u79F0").addText((text) => text.setPlaceholder("model-name").setValue(this.plugin.settings.customModelName).onChange(async (value) => {
        this.plugin.settings.customModelName = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("API \u7248\u672C (\u53EF\u9009)").setDesc("\u5982\u679C\u9700\u8981\u6307\u5B9AAPI\u7248\u672C\uFF0C\u8BF7\u5728\u6B64\u8F93\u5165").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1A2023-06-01").setValue(this.plugin.settings.customApiVersion).onChange(async (value) => {
        this.plugin.settings.customApiVersion = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(containerEl).setName("\u81EA\u5B9A\u4E49Prompt").setDesc("\u8BBE\u7F6E\u751F\u6210Anki\u5361\u7247\u7684\u63D0\u793A\u8BCD").addTextArea((text) => text.setPlaceholder('\u8BF7\u57FA\u4E8E\u4EE5\u4E0B\u5185\u5BB9\u521B\u5EFAAnki\u5361\u7247\uFF0C\u683C\u5F0F\u4E3A"\u95EE\u9898:::\u7B54\u6848"...').setValue(this.plugin.settings.customPrompt).onChange(async (value) => {
      this.plugin.settings.customPrompt = value;
      await this.plugin.saveSettings();
    }).inputEl.style.minHeight = "80px");
    new import_obsidian.Setting(containerEl).setName("\u76F4\u63A5\u63D2\u5165\u6587\u6863").setDesc("\u542F\u7528\u540E\uFF0C\u751F\u6210\u7684Anki\u5361\u7247\u5C06\u76F4\u63A5\u63D2\u5165\u5230\u6587\u6863\u672B\u5C3E\uFF0C\u800C\u4E0D\u662F\u663E\u793A\u5728\u5F39\u7A97\u4E2D").addToggle((toggle) => toggle.setValue(this.plugin.settings.insertToDocument).onChange(async (value) => {
      this.plugin.settings.insertToDocument = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Anki Connect \u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("Anki Connect URL").setDesc("Anki Connect API\u7684\u5730\u5740\uFF0C\u9ED8\u8BA4\u4E3A http://127.0.0.1:8765").addText((text) => text.setPlaceholder("http://127.0.0.1:8765").setValue(this.plugin.settings.ankiConnectUrl).onChange(async (value) => {
      this.plugin.settings.ankiConnectUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u9ED8\u8BA4\u724C\u7EC4").setDesc("\u6DFB\u52A0\u5361\u7247\u65F6\u7684\u9ED8\u8BA4\u724C\u7EC4\u540D\u79F0").addText((text) => text.setPlaceholder("Default").setValue(this.plugin.settings.defaultDeck).onChange(async (value) => {
      this.plugin.settings.defaultDeck = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u9ED8\u8BA4\u7B14\u8BB0\u7C7B\u578B").setDesc("\u6DFB\u52A0\u5361\u7247\u65F6\u7684\u9ED8\u8BA4\u7B14\u8BB0\u7C7B\u578B").addText((text) => text.setPlaceholder("Basic").setValue(this.plugin.settings.defaultNoteType).onChange(async (value) => {
      this.plugin.settings.defaultNoteType = value;
      await this.plugin.saveSettings();
    }));
  }
};